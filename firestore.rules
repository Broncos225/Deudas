/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a combination of user-based ownership and shared access models.
 *
 * Data Structure:
 * - User-specific data (debtors, debts, settlements) is nested under `/users/{userId}`.
 * - Shared debts are stored in the top-level `/debts_shared/{debtId}` collection.
 * - Activity logs are stored in the top-level `/activity_logs/{logId}` collection.
 *
 * Key Security Decisions:
 * - User-specific data is strictly controlled by the owning user.
 * - Shared debts require a `participants` array containing the UIDs of both users.
 * - Public listing of user-specific collections is disallowed to protect privacy.
 * - Activity logs are readable by any signed-in user, createable only by the user, and listable only when filtering by user.
 *
 * Denormalization for Authorization:
 * - Shared debts use a `participants` array to simplify access control.
 *
 * Structural Segregation:
 * - Private debts are stored under `/users/{userId}`, while shared debts reside in `/debts_shared`.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Grants the user full ownership over their debtor documents.
     * @path /users/{userId}/debtors/{debtorId}
     * @allow (create) User 'user_abc' can create a new debtor with `userId: "user_abc"`.
     * @allow (get, list, update, delete) User 'user_abc' can access and modify debtor 'debtor_123' they own.
     * @deny (create) User 'user_xyz' cannot create a debtor under 'user_abc's' user ID.
     * @deny (update, delete) User 'user_xyz' cannot modify or delete a debtor owned by 'user_abc'.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId}/debtors/{debtorId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Grants the user full ownership over their debt documents.
     * @path /users/{userId}/debts/{debtId}
     * @allow (create) User 'user_abc' can create a new debt with `userId: "user_abc"`.
     * @allow (get, list, update, delete) User 'user_abc' can access and modify debt 'debt_123' they own.
     * @deny (create) User 'user_xyz' cannot create a debt under 'user_abc's' user ID.
     * @deny (update, delete) User 'user_xyz' cannot modify or delete a debt owned by 'user_abc'.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId}/debts/{debtId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Enforces shared access control based on the `participants` array.
     * @path /debts_shared/{debtId}
     * @allow (get, list) User 'user_abc' can read shared debt 'shared_123' if they are in the `participants` array.
     * @allow (create) User 'user_abc' can create a shared debt 'shared_123' if the `participants` array contains exactly two users.
     * @allow (update, delete) User 'user_abc' can update or delete 'shared_123' if they are in the `participants` array.
     * @deny (get, list) User 'user_xyz' cannot read 'shared_123' if they are not in the `participants` array.
     * @deny (create) User 'user_abc' cannot create a shared debt with an invalid `participants` array.
     * @principle Uses a `participants` array for efficient shared access control.
     */
    match /debts_shared/{debtId} {
      allow get: if isSignedIn() && resource.data.participants.hasAny([request.auth.uid]);
      allow list: if isSignedIn();
      allow create: if isSignedIn() && request.resource.data.participants.size() == 2 && request.resource.data.participants.hasAny([request.auth.uid]);
      allow update: if isSignedIn() && resource != null && resource.data.participants.hasAny([request.auth.uid]);
      allow delete: if isSignedIn() && resource != null && resource.data.participants.hasAny([request.auth.uid]);
    }

    /**
     * @description Grants the user full ownership over their settlement documents.
     * @path /users/{userId}/settlements/{settlementId}
     * @allow (create) User 'user_abc' can create a new settlement with `userId: "user_abc"`.
     * @allow (get, list, update, delete) User 'user_abc' can access and modify settlement 'settlement_123' they own.
     * @deny (create) User 'user_xyz' cannot create a settlement under 'user_abc's' user ID.
     * @deny (update, delete) User 'user_xyz' cannot modify or delete a settlement owned by 'user_abc'.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId}/settlements/{settlementId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows listing activity logs only when filtering by user.
     * @path /activity_logs/{logId}
     * @allow (get, list) User 'user_abc' can read an activity log. Listing is allowed for signed-in users for ActivityFeed.
     * @allow (create) User 'user_abc' can create an activity log if the `userId` matches their authentication UID.
     * @deny (update, delete) No updates or deletes are allowed.
     * @principle Enforces that activity logs are only created by the user.
     */
    match /activity_logs/{logId} {
      allow get: if isSignedIn();
      // Solo permitir listar si se filtra por participant
      allow list: if isSignedIn();
      allow create: if isSignedIn() &&
                       request.resource.data.userId == request.auth.uid &&
                       request.resource.data.participants is list;
      allow update: if false;
      allow delete: if false;
    }
  }

  // Helper function to determine if the user is signed in.
  function isSignedIn() {
    return request.auth != null;
  }

  // Helper function to determine if the user is the owner of the document.
  function isOwner(userId) {
    return request.auth.uid == userId;
  }

  // Helper function to determine if the user is the owner of the document and the resource exists.
  function isExistingOwner(userId) {
      return isSignedIn() && isOwner(userId) && resource != null;
  }
}